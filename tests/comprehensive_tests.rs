//! Comprehensive tests for all public helper functions in generated FIX code.
//!
//! This module tests the actual helper functions generated by the codegen,
//! ensuring they work correctly across all data types, edge cases, and
//! real-world scenarios.

use std::collections::HashSet;
use std::sync::{Arc, Mutex};
use std::thread;

// Import helper functions from the fix44-forge-helpers crate
use fix44_forge_helpers::*;

/// Test module for reading functions
mod reading {
    use super::*;

    #[test]
    fn read_bool_variants() {
        assert_eq!(read_bool(b"Y"), true);
        assert_eq!(read_bool(b"N"), false);
        assert_eq!(read_bool(b""), false);
        assert_eq!(read_bool(b"Z"), false);
        assert_eq!(read_bool(b"1"), false); // Only Y is true
    }

    #[test]
    fn read_str_basic() {
        assert_eq!(read_str(b"hello"), "hello");
        assert_eq!(read_str(b""), "");
        assert_eq!(read_str(b"FIX.4.4"), "FIX.4.4");
    }

    #[test]
    fn read_u16_variants() {
        assert_eq!(read_u16(b"0"), 0);
        assert_eq!(read_u16(b"1"), 1);
        assert_eq!(read_u16(b"65535"), 65535);
        assert_eq!(read_u16(b""), 0);
        assert_eq!(read_u16(b"123abc"), 123); // Stops at non-digit
    }

    #[test]
    fn read_u32_variants() {
        assert_eq!(read_u32(b"0"), 0);
        assert_eq!(read_u32(b"4294967295"), 4294967295);
        assert_eq!(read_u32(b"123"), 123);
        assert_eq!(read_u32(b""), 0);
        assert_eq!(read_u32(b"999x"), 999);
    }

    #[test]
    fn read_u64_variants() {
        assert_eq!(read_u64(b"0"), 0);
        assert_eq!(read_u64(b"18446744073709551615"), 18446744073709551615);
        assert_eq!(read_u64(b"123456789"), 123456789);
        assert_eq!(read_u64(b""), 0);
    }

    #[test]
    fn read_i16_variants() {
        assert_eq!(read_i16(b"0"), 0);
        assert_eq!(read_i16(b"32767"), 32767);
        assert_eq!(read_i16(b"-32768"), -32768);
        assert_eq!(read_i16(b"-1"), -1);
        assert_eq!(read_i16(b""), 0);
    }

    #[test]
    fn read_i32_variants() {
        assert_eq!(read_i32(b"0"), 0);
        assert_eq!(read_i32(b"2147483647"), 2147483647);
        assert_eq!(read_i32(b"-2147483648"), -2147483648);
        assert_eq!(read_i32(b"-1"), -1);
        assert_eq!(read_i32(b""), 0);
    }

    #[test]
    fn read_i64_variants() {
        assert_eq!(read_i64(b"0"), 0);
        assert_eq!(read_i64(b"9223372036854775807"), 9223372036854775807);
        assert_eq!(read_i64(b"-9223372036854775808"), -9223372036854775808);
        assert_eq!(read_i64(b"-1"), -1);
        assert_eq!(read_i64(b""), 0);
    }

    #[test]
    fn read_f32_variants() {
        assert_eq!(read_f32(b"0"), 0.0);
        assert_eq!(read_f32(b"1.5"), 1.5);
        assert_eq!(read_f32(b"-2.5"), -2.5);
        assert_eq!(read_f32(b"123.456"), 123.456);
        assert_eq!(read_f32(b""), 0.0);

        // Test precision limits
        let result = read_f32(b"0.123456789");
        assert!((result - 0.123456789).abs() < 1e-6);
    }

    #[test]
    fn read_f64_variants() {
        assert_eq!(read_f64(b"0"), 0.0);
        assert_eq!(read_f64(b"1.5"), 1.5);
        assert_eq!(read_f64(b"-2.5"), -2.5);
        assert_eq!(read_f64(b"123.456789012345"), 123.456789012345);
        assert_eq!(read_f64(b""), 0.0);

        // Test precision
        let result = read_f64(b"0.123456789012345678");
        assert!((result - 0.123456789012345678).abs() < 1e-15);
    }
}

/// Test module for writing functions
mod writing {
    use super::*;

    #[test]
    fn write_u16_variants() {
        let test_cases = [0, 1, 9, 10, 99, 100, 999, 1000, 9999, 65535];

        for &n in &test_cases {
            let mut buf = [0u8; 16];
            let len = write_u16(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();
            assert_eq!(written, n.to_string());

            // Verify roundtrip
            assert_eq!(read_u16(&buf[..len]), n);
        }
    }

    #[test]
    fn write_u32_variants() {
        let test_cases = [0, 1, 123, 1000, 999999, 4294967295];

        for &n in &test_cases {
            let mut buf = [0u8; 16];
            let len = write_u32(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();
            assert_eq!(written, n.to_string());

            // Verify roundtrip
            assert_eq!(read_u32(&buf[..len]), n);
        }
    }

    #[test]
    fn write_u64_variants() {
        let test_cases = [0, 1, 123456789, 18446744073709551615];

        for &n in &test_cases {
            let mut buf = [0u8; 32];
            let len = write_u64(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();
            assert_eq!(written, n.to_string());

            // Verify roundtrip
            assert_eq!(read_u64(&buf[..len]), n);
        }
    }

    #[test]
    fn write_i16_variants() {
        let test_cases = [0, 1, -1, 32767, -32768, 123, -123];

        for &n in &test_cases {
            let mut buf = [0u8; 16];
            let len = write_i16(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();
            assert_eq!(written, n.to_string());

            // Verify roundtrip
            assert_eq!(read_i16(&buf[..len]), n);
        }
    }

    #[test]
    fn write_i32_variants() {
        let test_cases = [0, 1, -1, 2147483647, -2147483648, 123456, -123456];

        for &n in &test_cases {
            let mut buf = [0u8; 16];
            let len = write_i32(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();
            assert_eq!(written, n.to_string());

            // Verify roundtrip
            assert_eq!(read_i32(&buf[..len]), n);
        }
    }

    #[test]
    fn write_i64_variants() {
        let test_cases = [
            0,
            1,
            -1,
            9223372036854775807,
            -9223372036854775808,
            123456789,
            -123456789,
        ];

        for &n in &test_cases {
            let mut buf = [0u8; 32];
            let len = write_i64(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();
            assert_eq!(written, n.to_string());

            // Verify roundtrip
            assert_eq!(read_i64(&buf[..len]), n);
        }
    }

    #[test]
    fn write_f32_no_scientific_notation() {
        let test_cases = [0.0, 1.0, -1.0, 123.45, -123.45, 0.0001, 1000000.25];

        for &n in &test_cases {
            let mut buf = [0u8; 64];
            let len = write_f32(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();

            // Must not contain scientific notation
            assert!(!written.contains('e'));
            assert!(!written.contains('E'));

            // Should be reasonably close on roundtrip
            let parsed = read_f32(&buf[..len]);
            assert!((n - parsed).abs() <= 1e-6 * n.abs().max(1.0));
        }
    }

    #[test]
    fn write_f64_no_scientific_notation() {
        let test_cases = [
            0.0,
            1.0,
            -1.0,
            123.456789,
            -123.456789,
            0.000001,
            1000000.123456,
        ];

        for &n in &test_cases {
            let mut buf = [0u8; 128];
            let len = write_f64(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();

            // Must not contain scientific notation
            assert!(!written.contains('e'));
            assert!(!written.contains('E'));

            // Should be reasonably close on roundtrip
            let parsed = read_f64(&buf[..len]);
            assert!((n - parsed).abs() <= 1e-12 * n.abs().max(1.0));
        }
    }

    #[test]
    fn write_u128_variants() {
        let test_cases = [0u128, 1, 123456789, u64::MAX as u128, u128::MAX];

        for &n in &test_cases {
            let mut buf = [0u8; 64];
            let len = write_u128(&mut buf, 0, n);

            assert!(len > 0);
            let written = std::str::from_utf8(&buf[..len]).unwrap();
            assert_eq!(written, n.to_string());
        }
    }
}

/// Test module for tag writing functions
mod tag_writing {
    use super::*;

    #[test]
    fn write_tag_and_bool_variants() {
        let mut buf = [0u8; 16];

        // Test true
        let len = write_tag_and_bool(&mut buf, 0, b"43=", true);
        assert_eq!(&buf[..len], b"43=Y\x01");

        // Test false
        let len = write_tag_and_bool(&mut buf, 0, b"43=", false);
        assert_eq!(&buf[..len], b"43=N\x01");
    }

    #[test]
    fn write_tag_and_str_variants() {
        let mut buf = [0u8; 32];

        let len = write_tag_and_str(&mut buf, 0, b"55=", "EURUSD");
        assert_eq!(&buf[..len], b"55=EURUSD\x01");

        // Empty string
        let len = write_tag_and_str(&mut buf, 0, b"55=", "");
        assert_eq!(&buf[..len], b"55=\x01");
    }

    #[test]
    fn write_tag_and_bytes_variants() {
        let mut buf = [0u8; 32];

        let len = write_tag_and_bytes(&mut buf, 0, b"128=", b"HELLO");
        assert_eq!(&buf[..len], b"128=HELLO\x01");

        // Empty bytes
        let len = write_tag_and_bytes(&mut buf, 0, b"128=", b"");
        assert_eq!(&buf[..len], b"128=\x01");
    }

    #[test]
    fn write_tag_and_u16_variants() {
        let test_cases = [(34, 123u16), (35, 0), (36, 65535)];

        for (tag, value) in test_cases {
            let mut buf = [0u8; 32];
            let tag_bytes = format!("{}=", tag).into_bytes();
            let len = write_tag_and_u16(&mut buf, 0, &tag_bytes, value);

            let expected = format!("{}={}\x01", tag, value).into_bytes();
            assert_eq!(&buf[..len], expected);
        }
    }

    #[test]
    fn write_tag_and_u32_variants() {
        let test_cases = [(34, 123u32), (35, 0), (36, 4294967295)];

        for (tag, value) in test_cases {
            let mut buf = [0u8; 32];
            let tag_bytes = format!("{}=", tag).into_bytes();
            let len = write_tag_and_u32(&mut buf, 0, &tag_bytes, value);

            let expected = format!("{}={}\x01", tag, value).into_bytes();
            assert_eq!(&buf[..len], expected);
        }
    }

    #[test]
    fn write_tag_and_u64_variants() {
        let test_cases = [(34, 123u64), (35, 0), (36, 18446744073709551615)];

        for (tag, value) in test_cases {
            let mut buf = [0u8; 64];
            let tag_bytes = format!("{}=", tag).into_bytes();
            let len = write_tag_and_u64(&mut buf, 0, &tag_bytes, value);

            let expected = format!("{}={}\x01", tag, value).into_bytes();
            assert_eq!(&buf[..len], expected);
        }
    }

    #[test]
    fn write_tag_and_i16_variants() {
        let test_cases = [(34, 123i16), (35, -123), (36, 0), (37, 32767), (38, -32768)];

        for (tag, value) in test_cases {
            let mut buf = [0u8; 32];
            let tag_bytes = format!("{}=", tag).into_bytes();
            let len = write_tag_and_i16(&mut buf, 0, &tag_bytes, value);

            let expected = format!("{}={}\x01", tag, value).into_bytes();
            assert_eq!(&buf[..len], expected);
        }
    }

    #[test]
    fn write_tag_and_i32_variants() {
        let test_cases = [
            (34, 123i32),
            (35, -123),
            (36, 0),
            (37, 2147483647),
            (38, -2147483648),
        ];

        for (tag, value) in test_cases {
            let mut buf = [0u8; 32];
            let tag_bytes = format!("{}=", tag).into_bytes();
            let len = write_tag_and_i32(&mut buf, 0, &tag_bytes, value);

            let expected = format!("{}={}\x01", tag, value).into_bytes();
            assert_eq!(&buf[..len], expected);
        }
    }

    #[test]
    fn write_tag_and_i64_variants() {
        let test_cases = [
            (34, 123i64),
            (35, -123),
            (36, 0),
            (37, 9223372036854775807),
            (38, -9223372036854775808),
        ];

        for (tag, value) in test_cases {
            let mut buf = [0u8; 64];
            let tag_bytes = format!("{}=", tag).into_bytes();
            let len = write_tag_and_i64(&mut buf, 0, &tag_bytes, value);

            let expected = format!("{}={}\x01", tag, value).into_bytes();
            assert_eq!(&buf[..len], expected);
        }
    }

    #[test]
    fn write_tag_and_f32_variants() {
        let test_cases = [123.45f32, -123.45, 0.0, 0.123456];

        for value in test_cases {
            let mut buf = [0u8; 64];
            let len = write_tag_and_f32(&mut buf, 0, b"44=", value);

            // Should start with tag
            assert!(buf.starts_with(b"44="));
            // Should end with SOH
            assert_eq!(buf[len - 1], 0x01);
            // Should not contain scientific notation
            let content = std::str::from_utf8(&buf[3..len - 1]).unwrap();
            assert!(!content.contains('e') && !content.contains('E'));
        }
    }

    #[test]
    fn write_tag_and_f64_variants() {
        let test_cases = [123.456789f64, -123.456789, 0.0, 0.123456789012];

        for value in test_cases {
            let mut buf = [0u8; 128];
            let len = write_tag_and_f64(&mut buf, 0, b"44=", value);

            // Should start with tag
            assert!(buf.starts_with(b"44="));
            // Should end with SOH
            assert_eq!(buf[len - 1], 0x01);
            // Should not contain scientific notation
            let content = std::str::from_utf8(&buf[3..len - 1]).unwrap();
            assert!(!content.contains('e') && !content.contains('E'));
        }
    }
}

/// Test module for special functions
mod special_functions {
    use super::*;

    #[test]
    fn write_tag_and_current_timestamp_format() {
        let mut buf = [0u8; 64];
        let len = write_tag_and_current_timestamp(&mut buf, 0, b"52=");

        // Should be "52=" + 21 chars + SOH = 25 total
        assert_eq!(len, 25);
        assert_eq!(&buf[..3], b"52=");
        assert_eq!(buf[len - 1], 0x01);

        let timestamp = &buf[3..24];

        // Verify format: YYYYMMDD-HH:MM:SS.mmm
        assert_eq!(timestamp[8], b'-');
        assert_eq!(timestamp[11], b':');
        assert_eq!(timestamp[14], b':');
        assert_eq!(timestamp[17], b'.');

        // All other positions should be digits
        for (i, &b) in timestamp.iter().enumerate() {
            if ![8, 11, 14, 17].contains(&i) {
                assert!(b.is_ascii_digit(), "Non-digit at position {}: {}", i, b);
            }
        }
    }

    #[test]
    fn encode_base36_fixed13_format() {
        let mut buf = [0u8; 32];

        // Test various values
        let test_values = [0u64, 1, 123456789, u64::MAX];

        for value in test_values {
            buf.fill(0);
            let len = encode_base36_fixed13(&mut buf, 0, value);

            assert_eq!(len, 13);

            // All characters should be base36 (0-9, A-Z)
            for &b in &buf[..13] {
                assert!(
                    (b'0'..=b'9').contains(&b) || (b'A'..=b'Z').contains(&b),
                    "Invalid base36 character: {}",
                    b as char
                );
            }
        }
    }

    #[test]
    fn write_tag_and_clordid_format() {
        let mut buf = [0u8; 32];
        let len = write_tag_and_ClOrdID(&mut buf, 0, b"11=");

        // Should be "11=" + 13 chars + SOH = 17 total
        assert_eq!(len, 17);
        assert_eq!(&buf[..3], b"11=");
        assert_eq!(buf[len - 1], 0x01);

        let clordid = &buf[3..16];
        assert_eq!(clordid.len(), 13);

        // All characters should be base36
        for &b in clordid {
            assert!(
                (b'0'..=b'9').contains(&b) || (b'A'..=b'Z').contains(&b),
                "Invalid base36 character in ClOrdID: {}",
                b as char
            );
        }
    }

    #[test]
    fn clordid_uniqueness_sequential() {
        let mut seen = HashSet::new();
        let mut buf = [0u8; 32];

        // Generate many IDs and ensure uniqueness
        for _ in 0..10000 {
            let len = write_tag_and_ClOrdID(&mut buf, 0, b"11=");
            assert_eq!(len, 17);

            let id: [u8; 13] = buf[3..16].try_into().unwrap();
            assert!(seen.insert(id), "Duplicate ClOrdID generated");
        }
    }

    #[test]
    fn clordid_uniqueness_parallel() {
        const THREADS: usize = 4;
        const PER_THREAD: usize = 1000;

        let global_set = Arc::new(Mutex::new(HashSet::<[u8; 13]>::new()));
        let mut handles = vec![];

        for _ in 0..THREADS {
            let global_set = Arc::clone(&global_set);
            handles.push(thread::spawn(move || {
                let mut local_ids = Vec::new();
                let mut buf = [0u8; 32];

                for _ in 0..PER_THREAD {
                    let len = write_tag_and_ClOrdID(&mut buf, 0, b"11=");
                    assert_eq!(len, 17);
                    local_ids.push(buf[3..16].try_into().unwrap());
                }

                let mut global = global_set.lock().unwrap();
                for id in local_ids {
                    assert!(global.insert(id), "Duplicate ClOrdID across threads");
                }
            }));
        }

        for handle in handles {
            handle.join().unwrap();
        }
    }
}

/// Test module for edge cases and error conditions
mod edge_cases {
    use super::*;

    #[test]
    fn empty_buffer_handling() {
        // Test read functions with empty input
        assert_eq!(read_u16(b""), 0);
        assert_eq!(read_u32(b""), 0);
        assert_eq!(read_u64(b""), 0);
        assert_eq!(read_i16(b""), 0);
        assert_eq!(read_i32(b""), 0);
        assert_eq!(read_i64(b""), 0);
        assert_eq!(read_f32(b""), 0.0);
        assert_eq!(read_f64(b""), 0.0);
        assert_eq!(read_bool(b""), false);
        assert_eq!(read_str(b""), "");
    }

    #[test]
    fn invalid_character_handling() {
        // Read functions should stop at first invalid character
        assert_eq!(read_u16(b"123abc"), 123);
        assert_eq!(read_u32(b"456def"), 456);
        assert_eq!(read_u64(b"789xyz"), 789);
        assert_eq!(read_i16(b"123$"), 123);
        assert_eq!(read_i32(b"-456#"), -456);
        assert_eq!(read_i64(b"789@"), 789);
    }

    #[test]
    fn boundary_values() {
        // Test boundary values for all integer types

        // u16
        assert_eq!(read_u16(b"0"), 0);
        assert_eq!(read_u16(b"65535"), 65535);

        // u32
        assert_eq!(read_u32(b"0"), 0);
        assert_eq!(read_u32(b"4294967295"), 4294967295);

        // u64
        assert_eq!(read_u64(b"0"), 0);
        assert_eq!(read_u64(b"18446744073709551615"), 18446744073709551615);

        // i16
        assert_eq!(read_i16(b"-32768"), -32768);
        assert_eq!(read_i16(b"32767"), 32767);

        // i32
        assert_eq!(read_i32(b"-2147483648"), -2147483648);
        assert_eq!(read_i32(b"2147483647"), 2147483647);

        // i64
        assert_eq!(read_i64(b"-9223372036854775808"), -9223372036854775808);
        assert_eq!(read_i64(b"9223372036854775807"), 9223372036854775807);
    }

    #[test]
    fn floating_point_special_cases() {
        // Test zero and negative zero
        assert_eq!(read_f32(b"0"), 0.0);
        assert_eq!(read_f32(b"-0"), -0.0);
        assert_eq!(read_f64(b"0"), 0.0);
        assert_eq!(read_f64(b"-0"), -0.0);

        // Test very small numbers
        let small_f32 = read_f32(b"0.000001");
        assert!((small_f32 - 0.000001).abs() < 1e-9);

        let small_f64 = read_f64(b"0.000000000001");
        assert!((small_f64 - 0.000000000001).abs() < 1e-15);
    }

    #[test]
    fn buffer_offset_handling() {
        // Test that functions properly handle non-zero offsets
        let mut buf = [0u8; 64];

        // Write at various offsets
        let len1 = write_u32(&mut buf, 10, 123);
        let len2 = write_u32(&mut buf, 20, 456);

        assert!(len1 > 0);
        assert!(len2 > 0);

        // Verify data at correct positions
        assert_eq!(read_u32(&buf[10..10 + len1]), 123);
        assert_eq!(read_u32(&buf[20..20 + len2]), 456);
    }

    #[test]
    fn tag_writing_with_large_values() {
        let mut buf = [0u8; 128];

        // Test very large tag numbers and values
        let len = write_tag_and_u64(&mut buf, 0, b"99999=", u64::MAX);

        let expected = format!("99999={}\x01", u64::MAX);
        assert_eq!(&buf[..len], expected.as_bytes());
    }
}

// Performance-related tests (basic smoke tests, not benchmarks)
// mod performance_smoke {
//     use super::*;

//     #[test]
//     fn rapid_clordid_generation() {
//         let mut buf = [0u8; 32];
//         let start = std::time::Instant::now();

//         for _ in 0..10000 {
//             write_tag_and_ClOrdID(&mut buf, 0, b"11=");
//         }

//         let duration = start.elapsed();
//         // Should complete in reasonable time (this is not a precise benchmark)
//         assert!(
//             duration.as_millis() < 1000,
//             "ClOrdID generation too slow"
//         );
//     }

//     #[test]
//     fn large_message_iteration() {
//         // Create a large message with many fields
//         let mut large_msg = Vec::new();
//         for i in 1..=1000 {
//             large_msg.extend_from_slice(format!("{}={}\x01", i, i * 2).as_bytes());
//         }

//         let start = std::time::Instant::now();
//         let mut iter = TagValueIter::new(&large_msg);
//         let mut count = 0;

//         while iter.next().is_some() {
//             count += 1;
//         }

//         let duration = start.elapsed();
//         assert_eq!(count, 1000);
//         assert!(
//             duration.as_millis() < 100,
//             "Large message iteration too slow"
//         );
//     }
// }

// /// Integration tests that combine multiple helper functions
// mod integration {
//     use super::*;

//     #[test]
//     fn simple_tag_value_roundtrip() {
//         // Test a simple roundtrip of writing and parsing basic FIX fields
//         let mut buf = [0u8; 128];
//         let mut pos = 0;

//         // Write a few basic fields
//         pos += write_tag_and_str(
//             &mut buf, pos, b"8=", "FIX.4.4",
//         );
//         pos += write_tag_and_u16(&mut buf, pos, b"34=", 123);
//         pos += write_tag_and_str(&mut buf, pos, b"35=", "D");

//         // Parse them back
//         let mut iter = TagValueIter::new(&buf[..pos]);

//         // Check first field
//         let (tag, value) = iter
//             .next()
//             .expect("Should have first field");
//         assert_eq!(tag, 8);
//         assert_eq!(read_str(value), "FIX.4.4");

//         // Check second field
//         let (tag, value) = iter
//             .next()
//             .expect("Should have second field");
//         assert_eq!(tag, 34);
//         assert_eq!(read_u16(value), 123);

//         // Check third field
//         let (tag, value) = iter
//             .next()
//             .expect("Should have third field");
//         assert_eq!(tag, 35);
//         assert_eq!(read_str(value), "D");

//         // No more fields
//         assert!(iter.next().is_none());
//     }

//     #[test]
//     fn message_iterator_with_tag_parsing() {
//         // Create multiple complete messages
//         let mut messages = Vec::new();

//         for i in 1..=3 {
//             let mut buf = [0u8; 256];
//             let mut pos = 0;

//             pos += write_tag_and_str(
//                 &mut buf, pos, b"8=", "FIX.4.4",
//             );
//             pos += write_tag_and_u16(&mut buf, pos, b"9=", 50);
//             pos += write_tag_and_str(&mut buf, pos, b"35=", "D");
//             pos += write_tag_and_u32(&mut buf, pos, b"34=", i);
//             pos += write_tag_and_str(&mut buf, pos, b"10=", "123");

//             messages.extend_from_slice(&buf[..pos]);
//         }

//         // Parse all messages
//         let mut message_iter = FixMessageIter::new(&messages);
//         let mut parsed_messages = Vec::new();

//         while let Some(msg) = message_iter.next() {
//             let mut tag_iter = TagValueIter::new(msg);
//             let mut seq_num = 0;

//             while let Some((tag, value)) = tag_iter.next() {
//                 if tag == 34 {
//                     seq_num = read_u32(value);
//                     break;
//                 }
//             }

//             parsed_messages.push(seq_num);
//         }

//         assert_eq!(parsed_messages, vec![1, 2, 3]);
//     }
// }
